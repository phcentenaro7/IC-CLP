\section{Exact models for packing problems}

\subsection{The binary knapsack problem}

Informally, knapsack problems (KPs) may be described as finding the optimal combination of items from a set. Usually, this decision involves a certain value intrinsic to each item, and the objective is to maximize the total value of the selected items. To complicate this decision, items may have certain limiting values associated with them, which means not all of them may be selected.

The simplest example of a KP is the binary knapsack problem (BKP), also known as 0-1 knapsack problem \cite{ASSI2018}. It consists of a list of $n$ items, each with a value $v_i$ and a weight $w_i$ associated with them, for $i \in \{1,\dots,n\}$. A subset of items must be selected in order to maximize the total value, subject to a maximum weight capacity\footnote{This limiting factor, which can be interpreted as a bag or a container, is what gives the KP its name.} $C$. One may thus formulate the BKP as \cref{eq:ip:bkp},

\begin{align}
    \label[ip]{eq:ip:bkp}
    \begin{split}
        \max &\sum_{i=1}^{n}x_iv_i\\
        \textrm{s. t.}& \sum_{i=1}^{n}x_iw_i \leq C,\\
        &x_i \in \{0,1\} \quad \forall i \in \{1,\dots,n\},
    \end{split}
\end{align}
where $x_i$ are decision variables that specify whether item $i \in \{1,\dots,n\}$ has been selected or not.
% 
% By introducing slight variations to this formulation, it is possible to obtain different uses for the KP:

% \begin{itemize}
%     \item Unbounded knapsack problem (UKP): By letting $x_i \in \mathbb{N}$, the number of units of each item available is unlimited.
%     \item Fractional knapsack problem (FKP): By letting $x_i \in [0, 1]$, a fraction of each item can be selected.
%     \item Subset sum problem (SSP): When $v_i = w_i \, \forall i \in \{1,\dots,n\}$, the objective can be interpreted as maximizing the weight of the knapsack. Furthermore, if we demand that $\sum_{i=1}^{n}x_iw_i = C$, then the problem becomes finding the combination of items that produces sum $C$ exactly \cite{FEOFILOFF2020b}.
% \end{itemize}

The selection of subsets implies that an upper bound on the number of solutions to the BKP is $2^n$. Therefore, a natural first solution to the problem is a recursive binary tree algorithm \cite{FEOFILOFF2020a}. Let $I = \{1,\dots,n\}$ be a set enumerating the items that may be put in the knapsack. Then, by representing the values and weights of items as entries in vectors $v, w \in \mathbb{R}^n$, respectively, and the remaining knapsack weight capacity as $c \in \mathbb{R}$, we arrive at \cref{alg:kp tree algorithm} for an instance $\phi(n, c, X, s)$ of the problem, where $X \subseteq I$ is the set of selected items and $s$ is the sum of said items' values at the node.

\begin{algorithm}
    \caption{\href{https://github.com/phcentenaro7/IC-Knapsack/blob/main/Knapsack/USP/recursive_knapsack.jl}{Recursive binary tree algorithm for the KP: $\phi(n, c, X, s)$}}
    \label{alg:kp tree algorithm}
    \begin{algorithmic}[1]
        \If{$n=0$} \label{alg:kp tree algorithm ln1}
            \State return $(X, s)$
        \EndIf
        \State $X_1, s_1 \coloneqq \phi(n - 1, c, X, s)$ \label{alg:kp tree algorithm ln2}
        \State $X_2, s_2 \gets (\emptyset, \emptyset)$
        \If{$w_n \leq c$}
            \State $X_2, s_2 \coloneqq \phi(n - 1, c - w_n, X \cup \{n\}, s + v_n)$
        \EndIf
        \State $s \coloneqq max(s_1, s_2)$ \label{alg:kp tree algorithm ln3}
        \State $X_3 \gets 0$
        \If{$v = v_1$}
            \State $X_3 \coloneqq X_1$
        \Else
            \State $X_3 \coloneqq X_2$
        \EndIf
        \State return $(X_3, s)$
    \end{algorithmic}
\end{algorithm}

The algorithm consists of a top-bottom phase, in which the nodes are generated, and a bottom-top phase, in which the optimal solution is found. The top-bottom phase begins at \cref{alg:kp tree algorithm ln2}, where a new instance of $\phi$ is called with item $n$ discarded from the solution. Subsequently, if there is enough capacity left in the knapsack, a second node is generated, with $n$ included in the solution.

When $n = 0$ (\cref{alg:kp tree algorithm ln1}), it is impossible to generate a new node. Thus, the only remaining action is to return the solution set at the node and its value sum. Once the whole tree has been generated, \cref{alg:kp tree algorithm ln3} is reached. From this point on, the bottom-top phase begins, with each node selecting the best solution its children have to offer. Hence, the optimal solution is returned by the root node.

Due to the combinatorial nature of the KP, \cref{alg:kp tree algorithm} is only efficient at solving small problems \cite{FEOFILOFF2020a}.

\begin{example}
    Suppose we have a knapsack with maximum capacity $C = 5$ and three items. The weight vector is $w = [1, 2, 3]$ and the value vector is $v = [2, 4, 3]$. By applying \cref{alg:kp tree algorithm} to this problem, we obtain the tree in \cref{fig:kp tree example}.

    \begin{figure}[h]
        \centering
        \begin{tikzpicture}[>=Stealth]
            \graph[binary tree layout]{
              l0n1[as=0] -> {
                l1n1[as=0] -> {
                    l2n1[as=0] -> {
                        l3n1[as=0],
                        l3n2[as=2]
                    },
                    l2n2[as=4] -> {
                        l3n3[as=4],
                        l3n4[as=6]
                    }
                },
                l1n2[as=3] -> {
                    l2n3[as=3] -> {
                        l3n5[as=3],
                        l3n6[as=5]
                    },
                    l2n4[as=7] -> l3n7[as=7]
                }
              }
            };
        \end{tikzpicture}
        \caption{BKP binary tree algorithm example.}
        \label{fig:kp tree example}
    \end{figure}
    Each node in the tree represents the value sum of a feasible combination of items. It immediately becomes clear that the optimal solution in this case is $7$, with the combination of items $2$ and $3$. However, this is not obvious to the computer, which must solve every recursion and return to the root node first.
\end{example}

Dynamic programming \cite{BRADLEY1977,WAGNER1995} approaches to the KP exist \cite{FEOFILOFF2020a,HRISTAKEVA2005,DEMAINE2011}. The idea behind these approaches is to generate a table with solutions to subproblems of the KP, using previous calculations to shorten the path to the optimal solution.

Let $T \in \mathbb{R}^{(n+1) \times (c+1)}$ be the dynamic programming table for the KP. \cref{alg:kp dynamic programming} exemplifies how $T$ can be constructed and used to arrive at the optimal KP solution.

\begin{algorithm}
    \caption{\href{https://github.com/phcentenaro7/IC-Knapsack/blob/main/Knapsack/USP/dynamic_knapsack.jl}{Dynamic programming algorithm for the KP: $\Phi(n, c)$}}
    \label{alg:kp dynamic programming}
    \begin{algorithmic}[1]
        \For{$i$ from $1$ to $n+1$} \label{dpln1}
            \State $T_{i,1} \coloneqq 0$
        \EndFor
        \For{$j$ from $2$ to $c+1$}
            \State $T_{1,j} \coloneqq 0$ \label{dpln2}
            \For{$i$ from $2$ to $n+1$} \label{dpln3}
                \State $T_{i,j} \gets T_{i-1,j}$
                \If{$w_i \leq j$}
                    \State $T_{i,j} \gets \max{(T_{i,j}, v_{i-1} + T_{i-1,j-w_{i-1}})}$\label{dpln4}
                \EndIf
            \EndFor
        \EndFor
        \State $n_i, c_i, X \gets (n, c, \emptyset)$
        \While{$c_i > 0$} \label{dpln5}
            \If{$T_{n_i+1, c_i+1} \neq T_{n_i, c_i+1}$}
                \State $X \gets X \cup n_i$
                \State $c_i \gets c_i - w_n$
            \EndIf
            \State $n_i \gets n_i - 1$
        \EndWhile
        \State return X
    \end{algorithmic}
\end{algorithm}

$T_{i,j}$ represents the optimal value for a subproblem of the KP with $i - 1$ items and knapsack capacity $j - 1$. Consequently, no set of items can satisfy $j = 1$, and so $T_{i,1} = 0 \, \forall i \in \{1,\dots,n + 1\}$. Furthermore, since there are no items to select when $i = 1$, it follows that $T_{1,j} = 0 \, \forall j \in \{1,\dots,c + 1\}$. This explains lines \ref{dpln1} through \ref{dpln2}.

Lines \ref{dpln3} through \ref{dpln4} fill the remaining entries in the table. If $w_{i-1} > j - 1$, we simply keep the best solution found so far for capacity $j - 1$. Otherwise, we compare said solution with what would be obtained if $i - 1$ was selected. The larger value becomes entry $T_{i,j}$.

Once table $T$ is finished, starting at \cref{dpln5}, the process of determining what items constitute an optimal solution occurs. Following the logic of lines \ref{dpln3} through \ref{dpln4}, if $T_{i,j} = T_{i-1,j}$, then the current item has not been selected, and we may move on to the next item. Otherwise, the item is included in the final solution, and we move on to the next item with less capacity, $T_{i-1,j-w_i}$.

Though better than the binary tree approach, the dynamic programming algorithm's complexity is exponential as well \cite{FEOFILOFF2020a}. In fact, this approach is notably inefficient for large capacity values \cite{HRISTAKEVA2005}.

\begin{example}
    Suppose the following problem suggested by \textcite{FEOFILOFF2020a}: We have $4$ items and a capacity $5$. The weights and values of items are, respectively, $w = [4, 2, 1, 3]$ and $v = [500, 400, 300, 450]$. To find the optimal solution to this BKP, we start by applying the part of \cref{alg:kp dynamic programming} to generate \cref{tab:kp dynamic programming table}.

    \begin{table}[h]
        \centering
        \caption{BKP dynamic programming table example.}
        \label{tab:kp dynamic programming table}
        \begin{tabular}{|c c c c c c|}
            \hline
            0 & 0 & 0 & 0 & 0 & 0\\
            \hline
            0 & 0 & 0 & 0 & 500 & 500\\
            \hline
            0 & 0 & 400 & 400 & 500 & 500\\
            \hline
            0 & 300 & 400 & 700 & 700 & 800\\
            \hline
            0 & 300 & 400 & 700 & 750 & 850\\
            \hline
        \end{tabular}
    \end{table}

    Next, we start looking for the solution from the table's bottom right entry. We note that $T_{5,6} \neq T_{4,6}$. This means that item $4 \in X$ (the solution set). Next, we investigate item $3$. Since $4 \in X$, that means the capacity is now at $5 - w_4 = 2$. So we look at $T_{4,3}$, which is equal to $T_{3,3}$. We conclude that $3 \notin X$. Moving up a row, $T_{3,3} \neq T_{2,3}$, which means $2 \in X$. By repeating this one more time, we conclude that $X = \{2,4\}$.
\end{example}

Along with these algorithms, an \href{https://github.com/phcentenaro7/IC-Knapsack/blob/main/Knapsack/Misc/1DKP.jl}{integer programming model} of the BKP was implemented in \texttt{JuMP}.

\subsection{The two-dimensional knapsack problem}

Since the BKP contains a single capacity constraint (see \cref{eq:ip:bkp}), we can think of each item as a line segment whose length is $w_i$. It follows that the sum of lengths of the items must not exceed capacity $C$.

We wish to extrapolate this geometric interpretation of the BKP in a way that allows us to solve problems related to areas and volumes. In other words, we want to formulate two- and three-dimensional knapsack problems. To arrive at such formulations, first consider the multidimensional knapsack problem (MKP) \cite{LAABADI2018}, formulated in \cref{eq:ip:mkp}.

\begin{align}
    \label[ip]{eq:ip:mkp}
    \begin{split}
        \max & \sum_{i=1}^{n}v_ix_i\\
        \text{s. t.}& \sum_{i=1}^{n}w_{ji}x_i \leq C_j, \quad \forall j \in \{1,\dots,d\}\\
        & x_i \in \{0,1\}, \quad \forall i \in \{1,\dots,n\}.
    \end{split}
\end{align}

A number of differences can be spotted in this model, compared to the BKP's. The first is the introduction of parameter $d \in \mathbb{R}$, the number of dimensions that are being taken into account. Capacity $C \in \mathbb{R}$ becomes $C \in \mathbb{R}^d$, and each item $i \in \{1,\dots,n\}$ now has an associated vector $w_{ji} \in \mathbb{R}^{d}$ describing its weight across the problem's dimensions.

Specifically in the case of two dimensions, we may rewrite this formulation as \cref{eq:ip:mkp2d}.

\begin{align}
    \label[ip]{eq:ip:mkp2d}
    \begin{split}
        \max & \sum_{i=1}^{n}v_ix_i\\
        \text{s. t.}& \sum_{i=1}^{n}w_ix_i \leq W,\\
        & \sum_{i=1}^{n}h_ix_i \leq H,\\
        & x_i \in \{0,1\}, \quad \forall i \in \{1,\dots,n\}.
    \end{split}
\end{align}

Here, $w_i$ and $h_i$ represent the width and height of item $i$, while $W$ and $H$ represent the width and height of the container where we wish to place the items. We assume both the items and the container to be rectangular.

Suppose we want to place three items within a $30 \times 20$ container. The width, height and value vectors for this problem are $w = [10, 10, 5]$, $h = [5, 10, 15]$ and $v = [10, 15, 5]$. Through the plot on the left in \cref{fig:mkp2d example}, we can see that this is a trivial task. All items are selected, and the optimal value is $30$.

Our MKP formulation begs to differ: Only items $1$ and $2$ are selected, for an optimal value of $25$. Why? The plot on the right illustrates the issue: The MKP is applying the line segment logic to multiple dimensions, as if each chosen subset of items ended up constituting a larger rectangle of dimensions $\sum_{i=1}^{n}w_i \times \sum_{i=1}^{n}h_i$.

\begin{figure}[h]
    \centering
    \begin{tikzpicture}
        % \begin{pgfonlayer}{background}
        %     \includegraphics[scale=0.3]{Hero-20Pedigree-20Cats_jpg.png}
        %  \end{pgfonlayer}
        \begin{axis}[title=Optimal solution, xmin=0, xmax=30, ymin=0, ymax=20, xtick={0, 10, 20, 30}, ytick={10, 20}, name=optimal]
            \filldraw [draw=black, fill=red!40] (axis cs:0,0) rectangle (axis cs:10, 5);
            \node [black] at (axis cs:5, 2.5){\small{1}};
            \filldraw [draw=black, fill=green!40] (axis cs:10, 0) rectangle (axis cs:20, 10);
            \node [black] at (axis cs:15, 5){\small{2}};
            \filldraw [draw=black, fill=blue!40] (axis cs:20, 0) rectangle (axis cs:25, 15);
            \node [black] at (axis cs:22.5, 7.5){\small{3}};
            \addplot [draw=none] coordinates{(0,0)};
        \end{axis}
        \begin{axis}[at=(optimal.right of east), anchor=west, title=MKP solution, xmin=0, xmax=30, ymin=0, ymax=20, xtick={0, 10, 20, 30}, ytick={10, 20}, name=wrong,  xshift=0.7cm]
            \fill [yellow!20] (axis cs:0,0) rectangle (axis cs:20,15);
            \filldraw [draw=black, fill=red!40] (axis cs:0,0) rectangle (axis cs:10, 5);
            \draw (axis cs:0,5) -- (axis cs:0,15);
            \draw (axis cs:10,0) -- (axis cs:20,0);
            \node [black] at (axis cs:5, 2.5){\small{1}};
            \filldraw [draw=black, fill=green!40] (axis cs:10, 5) rectangle (axis cs:20, 15);
            \node [black] at (axis cs:15, 10){\small{2}};
            \draw [dashed] (axis cs:0, 15) -- (axis cs:10, 15);
            \draw [dashed] (axis cs:20, 5) -- (axis cs:20, 0);
            \addplot [draw=none] coordinates{(0,0)};
        \end{axis}
    \end{tikzpicture}
    \caption{Two-dimensional items within a $30 \times 20$ container.}
    \label{fig:mkp2d example}
\end{figure}

We need to sophisticate our model's constraints in order to solve 2D knapsack problems. We begin by introducing variables $x_i, y_i \in \mathbb{R}$, which describe the position of each item's bottom-left corner. It immediately becomes clear that every selected item $i \in \{1,\dots,n\}$ must obey \cref{eq:2DKP item corner constraints},

\begin{align}
    \label[constraint set]{eq:2DKP item corner constraints}
    \begin{split}
        0 \leq x_i \leq W,\\
        0 \leq x_i + w_i \leq W,\\
        0 \leq y_i \leq H,\\
        0 \leq y_i + h_i \leq H,
    \end{split}
\end{align}
where $W$ and $H$ are the width and height of the container, respectively.

Our task is complicated by the need to avoid item overlap. To accomplish this, we adopt the approach described by \textcite{KALVELAGEN2021}. For every selected item $i, j \in \{1,\dots,n\}$ with $i \neq j$, at least one inequality from \cref{eq:2DKP no-overlap intro} must hold true.

\begin{subequations}
    \label[constraint set]{eq:2DKP no-overlap intro}
    \begin{align}
        x_i + w_i \leq x_j,\\
        x_j + w_j \leq x_i,\\
        y_i + h_i \leq y_j,\\
        y_j + h_j \leq y_i.
    \end{align}
\end{subequations}

If we force all of these constraints upon the model, that might result in slower solve times. Thus, we need a way to enforce one constraint \emph{or} another. In other words, we have \emph{alternative constraints} \cite{BRADLEY1977}.

To implement this behavior in a 2DKP model, \textcite{KALVELAGEN2021} resorts to \emph{conditional constraints}, defined by \textcite{BRADLEY1977} as constraints of the form

\begin{equation}
    f_1(x_1,x_2,\dots,x_n) > b_1 \Rightarrow f_2(x_1,x_2,\dots,x_n) \leq b_2.
\end{equation}

In our case, the desired relations are given by variables $\delta_{i,j,k} \in \{0,1\}, \, k \in \{1,\dots,4\}$:

\begin{align}
    \delta_{i,j,1} = 1 \Rightarrow x_i + w_i \leq x_j,\\
    \delta_{i,j,2} = 1 \Rightarrow x_j + w_j \leq x_i,\\
    \delta_{i,j,3} = 1 \Rightarrow y_i + h_i \leq y_j,\\
    \delta_{i,j,4} = 1 \Rightarrow y_j + h_j \leq y_i.
\end{align}

These constraints can be mathematically implemented as \emph{big M constraints}\footnote{the concept is similar to the big M method for solving linear programming problems \cite{BAZARAA2010,BERTSIMAS1997}}. The idea is to introduce a constant $M \to +\infty$ and rewrite the constraints as

\begin{align}
    x_i + w_i - M(1 - \delta_{i,j,1}) \leq x_j,\\
    x_j + w_j - M(1 - \delta_{i,j,2}) \leq x_i,\\
    y_i + h_i - M(1 - \delta_{i,j,3}) \leq y_j,\\
    y_j + h_j - M(1 - \delta_{i,j,4}) \leq y_i.
\end{align}

Finally, we add the following constraint:

\begin{equation}
    \sum_{k=1}^{n} \delta_{i,j,k} \geq 1.
\end{equation}

For $M \to +\infty$, if a certain constraint is not selected, it's obvious that the inequations hold. This remains true for any item smaller than the container when $M = \max\{W,H\}$.

It is possible to introduce rotations to this model. For this purpose, we create new variables $\sigma_i$. When item $i$ is rotated, $\sigma_i = 1$. Otherwise, $\sigma_i = 0$. Then, the following constraints must be introduced:

\begin{align}
    x'_i = x_i + (1-\sigma_i)w_i + \sigma_i h_i,\\
    y'_i = y_i + (1-\sigma_i)h_i + \sigma_i w_i.
\end{align}

% If $(x_i, y_i)$ represents the bottom-left corner of an item, then $(x'_i, y'_i)$ represent the top-right corner adjusted for the correct rotation.

Having made all of these considerations, we can finally produce our continuous 2DKP model. Here, $s_i$ are the decision variables. For brevity, consider $N = \{1,\dots,n\}$.

\begin{subequations}
    \label[mip]{eq:ip:2DKP continuous}
    \begin{align}
        \max&\sum_{i \in N}v_i s_i\\
        \text{s. t.}& 0 \leq x_i \leq W, \quad \forall i \in N,\\
        & 0 \leq x'_i \leq W, \quad \forall i \in N,\\
        & 0 \leq y_i \leq H, \quad \forall i \in N,\\
        & 0 \leq y'_i \leq H, \quad \forall i \in N,\\
        & x'_i = x_i + (1 - \sigma_i)w_i + \sigma_i h_i, \quad \forall i \in N,\\
        & y'_i = y_i + \sigma_i w_i + (1 - \sigma_i)h_i, \quad \forall i \in N,\\
        & x'_i - M(3 - \delta_{i,j,1} - s_i - s_j) \leq x_j, \quad \forall i \in N, \, \forall j \in N, \, i < j, \label[constraints]{eq:ip:2DKP continuous big M 1}\\
        & x'_j - M(3 - \delta_{i,j,2} - s_i - s_j) \leq x_i, \quad \forall i \in N, \, \forall j \in N, \, i < j, \label[constraints]{eq:ip:2DKP continuous big M 2}\\
        & y'_i - M(3 - \delta_{i,j,3} - s_i - s_j) \leq y_j, \quad \forall i \in N, \, \forall j \in N, \, i < j, \label[constraints]{eq:ip:2DKP continuous big M 3}\\
        & y'_j - M(3 - \delta_{i,j,4} - s_i - s_j) \leq y_i, \quad \forall i \in N, \, \forall j \in N, \, i < j, \label[constraints]{eq:ip:2DKP continuous big M 4}\\
        & \sum_{k=1}^{4} \delta_{i,j,k} \geq 1, \quad \forall i \in N, \, j \in N,\\
        & \delta_{i,j,k} \in \{0,1\}, \quad \forall i \in N, \, j \in N, \, k \in \{1,2,3,4\}\\
        & \sigma_i \in \{0,1\}, \quad \forall i \in N,\\ 
        & s_i \in \{0,1\}, \quad \forall i \in N.
    \end{align}
\end{subequations}

Note that we have made a few changes to \cref{eq:ip:2DKP continuous big M 1,eq:ip:2DKP continuous big M 2,eq:ip:2DKP continuous big M 3,eq:ip:2DKP continuous big M 4}. To make them even stronger, we require both items to have been selected for the constraints to take effect. Moreover, since these constraints go both ways, it is only necessary to evaluate them for $i < j$.

We have written an \href{https://github.com/phcentenaro7/IC-Knapsack/blob/957b87062cb846a6e30e7c0a9246ad8b6f7bd189/Knapsack/Kalvelagen/jump_2dknapsack_continuous.jl}{implementation} of the model proposed by \textcite{KALVELAGEN2021}, which is an equivalent to \cref{eq:ip:2DKP continuous} that is more geared towards computational work, making heavy use of matrices for conciseness.

\textcite{KALVELAGEN2021} also made a discrete 2DKP model, referred to as \emph{covering model}. Say each item's width and height is represented by continuous variables $\tilde{w}_i$ and $\tilde{h}_i$. We begin by discretizing these quantities as $w_i = \lceil\tilde{w}_i\rceil$ and $h_i = \lceil\tilde{h}_i\rceil$. The container is discretized with $W = \lfloor\tilde{W}\rfloor$ and $H = \lfloor\tilde{H}\rfloor$.

This initial process allows for the interpretation of items as collections of cells. As shown in \cref{fig:2DKP covering discretization example}, a $7.23 \times 5.55$ item (darker blue) takes $8 \times 6$ cells (lighter blue).

\begin{figure}[h]
    \centering
    \begin{tikzpicture}
        \begin{axis}[xshift=0.7cm, xmin=0, xmax=10, ymin=0, ymax=10, grid=both, minor tick num=1]
            \filldraw[draw=black,fill=blue!20] (axis cs:0, 0) rectangle (axis cs:8, 6);
            \filldraw[draw=black,fill=blue!60,dashed] (axis cs:0,0) rectangle (axis cs:7.23, 5.55);
        \end{axis}
    \end{tikzpicture}
    \caption{Discretization of an item for the 2DKP covering model.}
    \label{fig:2DKP covering discretization example}
\end{figure}

In the covering model, we introduce binary matrix $A \in \mathbb{R}^{n \times 2 \times W \times H}$. If item $k$ can be placed at cell $(i,j)$ with rotation $r$ without leaving the boundaries of the container, then $A_{k,i,j,r} = 1$. Otherwise, $A_{k,r,i,j} = 0$. By convention,

\begin{align}
    r = 1& \Rightarrow \text{item is not rotated,}\nonumber\\
    r = 2& \Rightarrow \text{item is rotated.}\nonumber
\end{align}

Next, we introduce binary matrix $C \in \mathbb{R}^{n \times 2 \times W \times H \times W \times H}$. If cells $(i',j')$ are covered as a result of item $k$ being placed at cell $(i,j)$ with rotation $r$, then $C_{k,r,i,j,i',j'} = 1$. Otherwise, $C_{k,r,i,j,i',j'} = 0$.

Lastly, we make the decision variables $s_{k,r,i,j}$, since item placement is based on the top-left cell of each item. This is enough to formulate \cref{eq:ip:2DKP covering}.

\begin{subequations}
    \label[ip]{eq:ip:2DKP covering}
    \begin{align}
        \max &\sum_{n,r,i,j \mid A_{n,r,i,j} = 1} v_i s_{k,r,i,j}\\
        \text{s. t.} &\sum_{k,r,i,j \mid C_{k,r,i,j,i',j'} = 1} s_{k,r,i,j} \leq 1, \quad \forall i' \in \{1,\dots,W\}, \, j' \in \{1,\dots,H\},\\
        &\sum_{r,i,j \mid A_{k,r,i,j} = 1} s_{k,r,i,j} \leq 1, \quad \forall k \in \{1,\dots,n\}\\
        &s_{k,r,i,j} \in \{0,1\}.
    \end{align}
\end{subequations}

We have also written an \href{https://github.com/phcentenaro7/IC-Knapsack/blob/957b87062cb846a6e30e7c0a9246ad8b6f7bd189/Knapsack/Kalvelagen/jump_2dknapsack_covering.jl}{implementation} of this model. The model we implemented is the one presented by \textcite{KALVELAGEN2021}, which is more memory-efficient than \cref{eq:ip:2DKP covering}, since it groups items of the same type together in the matrices.

\begin{example}
    Say we wish to place as many items as possible in a $30 \times 20$ container, from the following list:

    \begin{table}[h]
        \centering
        \begin{tabular}{cccc}
            \toprule
            \textbf{type} & \textbf{width} & \textbf{height} & \textbf{quantity}\\
            \midrule
            \textbf{1} & 9 & 6 & 4\\
            \textbf{2} & 7 & 7 & 3\\
            \textbf{3} & 5 & 10 & 4\\
            \textbf{4} & 14 & 14 & 2\\
            \textbf{5} & 6 & 5 & 6\\
            \textbf{6} & 3 & 8 & 5\\
            \bottomrule
        \end{tabular}
    \end{table}

    Since the idea is to maximize the number of items in the container, we consider all the items to be of equal value. By applying these data to \cref{eq:ip:2DKP covering}, we obtain the packing in \cref{fig:2DKP packing example}.

    \begin{figure}[h]
        \centering
        \begin{tikzpicture}
            \begin{axis}[xmin=0, xmax=30, ymin=0, ymax=20, xtick={0,10,...,30}, ytick={10,20}]
                \filldraw[fill=blue!40,draw=black] (axis cs:0,0) rectangle (axis cs:7, 7);
                \node [black] at (axis cs:3.5, 3.5){\small{2}};
                \filldraw[fill=blue!40,draw=black] (axis cs:0,7) rectangle (axis cs:7, 14);
                \node [black] at (axis cs:3.5, 10.5){\small{2}};
                \filldraw[fill=blue!40,draw=black] (axis cs:18,13) rectangle (axis cs:25, 20);
                \node [black] at (axis cs:21.5, 16.5){\small{2}};
                \filldraw[fill=green!40,draw=black] (axis cs:0,14) rectangle (axis cs:5, 20);
                \node [black] at (axis cs:2.5, 17){\small{5}};
                \filldraw[fill=green!40,draw=black] (axis cs:5,14) rectangle (axis cs:10, 20);
                \node [black] at (axis cs:7.5, 17){\small{5}};
                \filldraw[fill=green!40,draw=black] (axis cs:7,8) rectangle (axis cs:12, 14);
                \node [black] at (axis cs:9.5, 11){\small{5}};
                \filldraw[fill=green!40,draw=black] (axis cs:12,8) rectangle (axis cs:17, 14);
                \node [black] at (axis cs:14.5, 11){\small{5}};
                \filldraw[fill=green!40,draw=black] (axis cs:18,5) rectangle (axis cs:24, 10);
                \node [black] at (axis cs:21, 7.5){\small{5}};
                \filldraw[fill=green!40,draw=black] (axis cs:24,5) rectangle (axis cs:30, 10);
                \node [black] at (axis cs:27, 7.5){\small{5}};
                \filldraw[fill=red!40,draw=black] (axis cs:10,0) rectangle (axis cs:20,5);
                \node [black] at (axis cs:15, 2.5){\small{3}};
                \filldraw[fill=red!40,draw=black] (axis cs:20,0) rectangle (axis cs:30,5);
                \node [black] at (axis cs:25, 2.5){\small{3}};
                \filldraw[fill=red!40,draw=black] (axis cs:25,10) rectangle (axis cs:30,20);
                \node [black] at (axis cs:27.5, 15){\small{3}};
                \filldraw[fill=purple!40,draw=black] (axis cs:7,0) rectangle (axis cs:10,8);
                \node [black] at (axis cs:8.5, 4){\small{6}};
                \filldraw[fill=purple!40,draw=black] (axis cs:10,5) rectangle (axis cs:18,8);
                \node [black] at (axis cs:14, 6.5){\small{6}};
                \filldraw[fill=purple!40,draw=black] (axis cs:17,10) rectangle (axis cs:25,13);
                \node [black] at (axis cs:21, 11.5){\small{6}};
                \filldraw[fill=purple!40,draw=black] (axis cs:10,14) rectangle (axis cs:18,17);
                \node [black] at (axis cs:14, 15.5){\small{6}};
                \filldraw[fill=purple!40,draw=black] (axis cs:10,17) rectangle (axis cs:18,20);
                \node [black] at (axis cs:14, 18.5){\small{6}};
            \end{axis}
        \end{tikzpicture}
        \caption{Covering solution to a 2D knapsack example.}
        \label{fig:2DKP packing example}
    \end{figure}
\end{example}

\subsection{The three-dimensional knapsack problem}

With similar ideas to those behind \cref{eq:ip:2DKP continuous,eq:ip:2DKP covering}, a three-dimensional model is possible. \cref{eq:mip:3DKP Egeblad} is one such model, presented by \textcite{EGEBLAD2009}.

The container in this problem has volume $W \times H \times D$ (width, height and depth). Similarly, each item has associated dimensions $(w_i,h_i,d_i)$ and is positioned at coordinates $(x_i,y_i,z_i)$.

To handle no-overlap, this model has six binary variables that state where item $i$ is in regards to item $j$: $\ell_{ij}$ (left), $r_{ij}$ (right), $u_{ij}$ (under), $o_{ij}$ (over), $b_{ij}$ (behind), $f_{ij}$ (in front of).

Positioning constraints in this model are similar to \cref{eq:ip:2DKP continuous}. For example, if $\ell_{ij} = 1$, then \cref{eq:mip:3DKP Egeblad 2} may be rewritten as $x_i + w_i \leq x_j$.

It should be noted that \cref{eq:mip:3DKP Egeblad 1} does \emph{not} work in an actual implementation. This constraint only makes sense if at least $i$ or $j$ is selected, and will result in an unfeasible model if $s_i + s_j = 0$. This is why we rewrite this constraint as $\ell_{ij} + r_{ij} + u_{ij} + o_{ij} + b_{ij} + f_{ij} = s_i s_j$ in our \href{https://github.com/phcentenaro7/IC-Knapsack/blob/5a6cb381dc20d3dbfcf1a31c8181aadd1a6c9988/Knapsack/Egeblad/knapsack_model.jl#L47}{implementation} of this model.

One notable limitation of this model is that it does not support item rotations.

\begin{subequations}
    \label[mip]{eq:mip:3DKP Egeblad}
    \begin{align}
        \max &\sum_{i=1}^{n}v_i s_i\\
        \text{s. t.} & \ell_{ij} + r_{ij} + u_{ij} + o_{ij} + b_{ij} + f_{ij} = s_i + s_j - 1, \, i, j \in \{1,\dots,n\}, \label[constraint]{eq:mip:3DKP Egeblad 1}\\
        & x_i - x_j + W\ell_{ij} \leq W - w_i, \, i, j \in \{1,\dots,n\}, \label[constraints]{eq:mip:3DKP Egeblad 2}\\
        & x_j - x_i + Wr_{ij} \leq W - w_i, \, i, j \in \{1,\dots,n\},\\
        & y_i - y_j + Hu_{ij} \leq H - h_i, \, i, j \in \{1,\dots,n\},\\
        & y_j - y_i + Ho_{ij} \leq H - h_i, \, i, j \in \{1,\dots,n\},\\
        & z_i - z_j + Db_{ij} \leq D - d_i, \, i, j \in \{1,\dots,n\},\\
        & z_j - z_i + Df_{ij} \leq D - d_i, \, i, j \in \{1,\dots,n\},\\
        & 0 \leq x_i \leq W - w_i, \, i \in \{1,\dots,n\},\\
        & 0 \leq y_i \leq H - h_i, \, i \in \{1,\dots,n\},\\
        & 0 \leq z_i \leq Z - d_i, \, i \in \{1,\dots,n\},\\
        & \ell_{ij}, r_{ij}, u_{ij}, o_{ij}, b_{ij}, f_{ij} \in \{0,1\}, \, i \in \{1,\dots,n\},\\
        & s_i \in \{0,1\}, \, i \in \{1,\dots,n\},\\
        & x_i, y_i, z_i \geq 0, \, i \in \{1,\dots,n\}.
    \end{align}
\end{subequations}

Testing this model with a \href{function draw_3d_knapsack_solution(kv::KnapsackVectors)}{method} developed to visualize solutions to this formulation of the 3D knapsack, we obtain results such as the one in \cref{fig:3DKP Egeblad solution example} for a $20\times20\times20$ container and the items in \cref{tab:3DKP example items}. The best solution includes everything, except for the black item.

\begin{table}[h]
    \centering
    \caption{Set of items for the 3DKP.}
    \label{tab:3DKP example items}
    \begin{tabular}{cccccc}
        \toprule
        \textbf{color} & \textbf{length} & \textbf{width} & \textbf{height} & \textbf{quantity} & \textbf{value}\\
        \midrule
        \textbf{red} & 2 & 4 & 5 & 6 & 10\\
        \textbf{green} & 6 & 8 & 4 & 2 & 12\\
        \textbf{blue} & 5 & 10 & 7 & 2 & 15\\
        \textbf{gray} & 2 & 2 & 2 & 4 & 5\\
        \textbf{white} & 8 & 9 & 10 & 6 & 13\\
        \textbf{black} & 12 & 12 & 12 & 1 & 20\\
        \textbf{olive} & 3 & 7 & 10 & 2 & 15\\
        \textbf{teal} & 4 & 8 & 6 & 3 & 11\\
        \bottomrule
    \end{tabular}
\end{table}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.55]{images/Egeblad3Dexample.png}
    \caption{Solution example to a 3D knapsack problem.}
    \label{fig:3DKP Egeblad solution example}
\end{figure}

\subsection{Container loading problems}

When the KP is generalized to multiple containers of varying volumes, it becomes a multi-container loading problem\footnote{When these dimensions are the same for all containers, the KP becomes a bin-packing problem.} (CLP). A model for solving such problems has been proposed by \textcite{CHEN1995}. The model concerns $m$ containers and $N$ items. To each item are assigned positioning variables $(x_i, y_i, z_i)$ and dimensions $(p_i, q_i, r_i)$ representing length, width and height, respectively. Much like \cref{eq:mip:3DKP Egeblad}, this model uses binary variables to represent the placement of item $i$ relative to item $k$: $a_{ik}$ (left), $b_{ik}$ (right), $c_{ik}$ (behind), $d_{ik}$ (front), $e_{ik}$ (below), $f_{ik}$ (above).

If item $i$ is assigned to container $j$, then $s_{ij} = 1$; otherwise, $s_{ij} = 0$. Rotations are introduced to the model through nine binary variables: $l_{xi}, l_{yi}, l_{zi}, w_{xi}, w_{yi}, w_{zi}, h_{xi}, h_{yi}, h_{zi}$. These variables determine which axis an item's length, width or height is parallel to. For example, if $l_{xi} = 1$, then item $i$ has its length parallel to the X axis.Evidently, the rotation variables must obey \cref{eq:clp rotation variable constraints}.

\begin{subequations}
    \label[constraint set]{eq:clp rotation variable constraints}
    \begin{align}
        &l_{xi} + l_{yi} + l_{zi} = 1,\\
        &w_{xi} + w_{yi} + w_{zi} = 1,\\
        &h_{xi} + h_{yi} + h_{zi} = 1,\\
        &l_{xi} + w_{xi} + h_{xi} = 1,\\
        &l_{yi} + w_{yi} + h_{yi} = 1,\\
        &l_{zi} + w_{zi} + h_{zi} = 1.
    \end{align}
\end{subequations}

From this set of equations, \textcite{CHEN1995} obtain the following equalities:

\begin{subequations}
    \label[equation set]{eq:clp rotation equation set}
    \begin{align}
        &l_{yi} = 1 - l_{xi} - l_{zi},\\
        &w_{xi} = l_{zi} - w_{yi} + h_{zi},\\
        &w_{zi} = 1 - l_{zi} - h_{zi},\\
        &h_{xi} = 1 - l_{xi} - l_{zi} + w_{yi} - h_{zi},\\
        &h_{yi} = l_{xi} + l_{zi} - w_{yi}.
    \end{align}
\end{subequations}

The model that \textcite{CHEN1995} propose is \cref{eq:mip:CLP Chen}. By replacing the rotation variables with the equations in \cref{eq:clp rotation equation set}, this model becomes simpler to solve.

\begin{subequations}
    \label[mip]{eq:mip:CLP Chen}
    \begin{align}
        \min &\sum_{j=1}^{m}L_jW_jH_jn_j - \sum_{i=1}^{N}p_iq_ir_i \label[expression]{eq:objective chen}\\
        \text{s. t.} &x_i + p_i l_{xi} + q_i w_{xi} + r_i h_{xi} \leq x_k + (1 - a_{ik}) M, \, \forall i, k, \, i < k, \label[constraints]{eq:comp chen 1}\\
        &x_k + p_k l_{xk} + q_k w_{xk} + r_k h_{xk} \leq x_i + (1 - b_{ik}) M, \, \forall i, k, \, i < k, \label[constraints]{eq:comp chen 2}\\
        &y_i + q_i w_{yi} + p_i l_{yi} + r_i h_{yi} \leq y_k + (1 - c_{ik}) M, \, \forall i, k, \, i < k, \label[constraints]{eq:comp chen 3}\\
        &y_k + q_k w_{yk} + p_k l_{yk} + r_k h_{yk} \leq y_i + (1 - d_{ik}) M, \, \forall i, k, \, i < k, \label[constraints]{eq:comp chen 4}\\
        &z_i + r_i h_{zi} + q_i w_{zi} + p_i l_{zi} \leq z_k + (1 - e_{ik}) M, \, \forall i, k, \, i < k, \label[constraints]{eq:comp chen 5}\\
        &z_k + r_k h_{zk} + q_k w_{zk} + p_k l_{zk} \leq z_i + (1 - f_{ik}) M, \, \forall i, k, \, i < k, \label[constraints]{eq:comp chen 6}\\
        &a_{ik} + b_{ik} + c_{ik} + d_{ik} + e_{ik} + f_{ik} \geq s_{ij} + s_{kj} - 1, \, \forall i, k, j, \, i < k \label[constraints]{eq:comp chen 7}\\
        &\sum_{j=1}^{m} s_{ij} = 1, \, \forall i, \label[constraints]{eq:all items in containers chen}\\
        &\sum_{i=1}^{N} s_{ij} \leq M n_j, \, \forall j, \label[constraints]{eq:items only in selected containers chen}\\
        &x_i + p_i l_{xi} + q_i w_{xi} + r_i h_{xi} \leq L_j + (1 - s_{ij}) M, \, \forall i, j, \label[constraints]{eq:items bound x chen}\\
        &y_i + q_i w_{yi} + p_i l_{yi} + r_i h_{yi} \leq W_j + (1 - s_{ij}) M, \, \forall i, j, \label[constraints]{eq:items bound y chen}\\
        &z_i + r_i h_{zi} + q_i w_{zi} + p_i l_{zi} \leq H_j + (1 - s_{ij}) M, \, \forall i, j, \label[constraints]{eq:items bound z chen}\\
        &l_{xi}, l_{yi}, l_{zi}, w_{xi}, w_{yi}, w_{zi}, h_{xi}, h_{yi}, h_{zi} \in \{0,1\}, \, \forall i\\
        &a_{ik}, b_{ik}, c_{ik}, d_{ik}, e_{ik}, f_{ik}, s_{ij}, n_j \in \{0,1\}, \, \forall i\\
        &x_i, y_i, z_i \geq 0.
    \end{align}
\end{subequations}

\cref{eq:objective chen} defines the CLP's objective to minimize the container volume that goes unused. Decision variables $n_j$ indicate whether a container has been selected or not. \cref{eq:comp chen 1,eq:comp chen 2,eq:comp chen 3,eq:comp chen 4,eq:comp chen 5,eq:comp chen 6} establish the relative placements of items in container $j$, in the same vein as \cref{eq:mip:3DKP Egeblad}. To guarantee that these alternative constraints work, \cref{eq:comp chen 7} force at least one of the positional variables to equal one, whenever two items share the same container.

\cref{eq:all items in containers chen} make it so every item is assigned to exactly one container. \cref{eq:items only in selected containers chen} ensure that items are only assigned to selected containers. Finally, \cref{eq:items bound x chen,eq:items bound y chen,eq:items bound z chen} make it impossible for items to breach their container's boundaries.

Our \href{https://github.com/phcentenaro7/IC-Knapsack/blob/7f581ff02334992a6181a06adbce668b528caeba/Knapsack/Chen/clp.jl#L27}{implementation} of this model and a \href{https://github.com/phcentenaro7/IC-Knapsack/blob/7f581ff02334992a6181a06adbce668b528caeba/Knapsack/Chen/clp.jl#L122}{visualization method} allows us to verify that this CLP model works when tested with the item set in \cref{tab:3DKP example items} and two $20\times20\times20$ containers. \cref{fig:clp example solution} shows the solution to this problem.

\begin{figure}[h]
    \centering
    \begin{subfigure}{.4\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/ChenExampleContainer1.png}
        \caption{Container 1}
    \end{subfigure}
    \begin{subfigure}{.5\textwidth}
        \centering
        \includegraphics[width=0.8\linewidth]{images/ChenExampleContainer2.png}
        \caption{Container 2}
    \end{subfigure}
    \caption{Containers in an example solution to the CLP.}
    \label{fig:clp example solution}
\end{figure}

\subsection{Complexity of exact solutions}

The BKP is an NP-hard problem \cite{PISINGER2005}, which means that no algorithm is known that can solve it in polynomial time, and that if such an algorithm can be found, then all other problems in the NP category can also be solved in polynomial time (P = NP) \cite{ERICKSON2019}.

The dynamic programming solution to the BKP (\cref{alg:kp dynamic programming}) might elicit doubt about this affirmation. Recall that this algorithm creates a table that grows according to $nC$, and then updates each entry once. Then, the algorithm performs even fewer steps of backtracking to determine which items constitute the optimal solution. Hence, the algorithm's time complexity is $\mathcal{O}(nC)$.

However, for an algorithm to be \emph{truly} polynomial, it must also be polynomial when the \emph{length in bits} of the input is used as a metric. Otherwise, we have only a \emph{pseudo-polynomial} algorithm \cite{WENDLAND}, bounded above by a unary representation of the problem's values \cite{ERICKSON2019,VAZIRANI2001}. As this is the case for dynamic programming approaches to the BKP, no true polynomial time algorithm is known for it \cite{DUDLEY2016,PISINGER2005}.

\begin{example}

    We will show that the dynamic programming approach is pseudo-polynomial. Consider a BKP with $n > 0$ (the specific value is unimportant), and let us vary the value of $C$ in powers of 2, as shown in \cref{tab:kp runtimes table}.

    \begin{table}[h]
        \centering
        \caption{Comparison between unary and binary input lengths regarding runtime.}
        \label{tab:kp runtimes table}
        \begin{tabular}{cccc}
            \toprule
            \multicolumn{3}{c}{$C$} & Runtime\\
            \cmidrule(lr){1-3}
            Decimal & Unary & Binary &\\
            \midrule
            2 & 11 & 10 & 2\\
            4 & 1111 & 100 & 4\\
            8 & 11111111 & 1000 & 8\\
            16 & 1111111111111111 & 10000 & 16\\
            \bottomrule
        \end{tabular}
    \end{table}

    By counting, we see that there is a one-to-one relation between runtime and the number of ones in a unary representation of $C$. Hence, the dynamic programming solution is polynomial in this sense. For $b$ binary digits, though, runtime is $2^{b-1}$, which is exponential behavior. \cref{fig:unary vs binary time} illustrates both behaviors for larger values of $C$.

    \begin{figure}[h]
        \centering
        \begin{tikzpicture}
            \begin{axis}[legend pos=south east, xmode=log, ymode=log, grid=major, xmin=1, xmax=1000, ymin=1, ymax=1000, ytick={10,100,1000}, xlabel={Length of input $C$}, ylabel={Runtime}]
                \addplot[domain=1:1000,samples=100,color=red,style=densely dashed]{x};
                \addlegendentry{Unary time};
                \addplot[domain=1:1000, samples=100,color=blue]{2^x};
                \addlegendentry{Binary time};
            \end{axis}
        \end{tikzpicture}
        \caption{Unary vs binary time for the dynamic programming solution to the BKP}
        \label{fig:unary vs binary time}
    \end{figure}

\end{example}

The 2D, 3D and any multidimensional KP are \emph{strongly} NP-hard \cite{CAPRARA2004,GHOMI2013}, which means that not even a pseudo-polynomial algorithm is known for them.

To further complicate this matter, exact methods are notably inefficient at solving large-scale packing problems \cite{TSAO2024,SANTOS2019,PISINGER2005}. This is due to a multitude of reasons, the first being that KPs and CLPs make heavy use of binary (integer) variables to decide which items to select, which rotations to apply, where an item stands compared to another, etc. \textcite{BRADLEY1977} show the issue with this through the following example. Consider the problem

\begin{subequations}
    \begin{align}
        \max \, &z = 5x_1 + 8x_2,\\
        \text{s. t. } &x_1 + x_2 \leq 6,\\
        &5x_1 + 9x_2 \leq 45,\\
        &x_1, x_2 \in \mathbb{N}_0. \label[constraints]{eq:branch-and-bound integer constraints}
    \end{align}
\end{subequations}

\cref{fig:branch-and-bound example} shows part of the steps towards an exact solution to this problem, using a branch-and-bound approach. First, the problem is relaxed, which means  \cref{eq:branch-and-bound integer constraints} become $x_1, x_2 \in \mathbb{R}^+_0$. The problem is then solved with a linear programming method (e.g. simplex), yielding solution $(2.25,3.75)$. This is not a solution to the original problem, and no reliable rounding procedure exists in this circumstance, since the optimal integer solution is at $(0,5)$. So we must keep searching. Since both coordinates of the optimal solution to the relaxation are fractional, four subproblems may be derived from the original problem, by introducing constraints $x_1 \leq 2$, $x_1 \geq 3$, $x_2 \leq 3$ and $x_2 \geq 4$ to the problem. From this, we arrive at the four new polyhedra in \cref{fig:branch-and-bound example 2}.

\begin{figure}[h]
    \centering
    \begin{tikzpicture}
        \begin{axis}[title=Relaxed problem, xmin=0,xmax=9.5,ymin=0,ymax=6.5, minor tick num=1, grid=both, name=relaxed]
            \filldraw[fill=green!80!black, fill opacity=0.4] (axis cs:0,0) -- (axis cs:0,5) -- (axis cs:2.25,3.75) -- (axis cs:6,0) -- cycle;
            \addplot[domain=0:9,samples=2]{6-x};
            \addplot[domain=0:9,samples=2]{5-0.55555*x};
            \addplot[domain=0:9,samples=2,dashed,draw=red]{5.15625 - 0.625*x};
            \addplot[only marks, color=red] (2.25, 3.75);
            \addplot[only marks, color=blue] (0, 5);
            \node[right,color=red] at (axis cs:6.8, 1.3) {$z = 41.25$};
            \node[right,color=red] at (axis cs:2.5, 4) {$(2.25, 3.75)$};
        \end{axis}
    \end{tikzpicture}
    \caption{Linear programming relaxation}
    \label{fig:branch-and-bound example}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}
        \begin{axis}[title=Subproblems constrained in $x_1$, xmin=0,xmax=9.5,ymin=0,ymax=6.5, minor tick num=1, grid=both,name=constrinx1]
            \filldraw[fill=green!80!black, fill opacity=0.4] (axis cs:0,0) -- (axis cs:0,5) -- (axis cs:2,3.88888) -- (axis cs:2,0) -- cycle;
            \filldraw[fill=green!80!black, fill opacity=0.4] (axis cs:3,0) -- (axis cs:3,3) -- (axis cs:6,0) -- cycle;
            \addplot[domain=0:9,samples=2]{6-x};
            \addplot[domain=0:9,samples=2]{5-0.55555*x};
            \addplot[domain=0:9,samples=2,dashed,draw=red]{5 - 0.625*x};
            \addplot[only marks, color=blue] (0, 5);
            \node[right,color=red] at (axis cs:6.8, 1.3) {$z = 40$};
        \end{axis}
        \begin{axis}[at=(constrinx1.right of east), anchor=west, title=Subproblems constrained in $x_2$, xshift=0.7cm, xmin=0,xmax=9.5,ymin=0,ymax=6.5, minor tick num=1, grid=both]
            \filldraw[fill=green!80!black, fill opacity=0.4] (axis cs:0,0) -- (axis cs:0,3) -- (axis cs:3,3) -- (axis cs:6,0) -- cycle;
            \filldraw[fill=green!80!black, fill opacity=0.4] (axis cs:0,4) -- (axis cs:0,5) -- (axis cs:1.8,4) -- cycle;
            \addplot[domain=0:9,samples=2]{6-x};
            \addplot[domain=0:9,samples=2]{5-0.55555*x};
            \addplot[domain=0:9,samples=2,dashed,draw=red]{5 - 0.625*x};
            \addplot[only marks, color=blue] (0, 5);
            \node[right,color=red] at (axis cs:6.8, 1.3) {$z = 40$};
        \end{axis}
    \end{tikzpicture}
    \caption{Branch-and-bound subproblems}
    \label{fig:branch-and-bound example 2}
\end{figure}

Effectively, a tree is generated with subproblems for nodes. Since the subproblems themselves can be cut into other subproblems, a real problem's tree may quickly grow thousands of nodes. Though there are procedures to determine if the integer solution to a subproblem is an optimal solution to the original problem, this does not guarantee that exact solutions can be found in a reasonable amount of time.

One particularly bad characteristic of the continuous 2DKP, the 3DKP and the CLP formulations presented in this section (\cref{eq:ip:2DKP continuous,eq:mip:3DKP Egeblad,eq:mip:CLP Chen}) is that their alternative constraints rely on big M constants that reduce the models' \emph{tightness}. As \textcite{EGEBLAD2009} remark, "These [constraints] will loose their effect when solving the LP-relaxation, and thus bounds from LP-relaxation are in general
far from the MIP-optimal solution value."

An important consequence of these issues is that contemporary approaches to real KP and CLP problems involve the use of heuristics to determine near-optimal solutions in an adequate amount of time. Nonetheless, exact methods can still aid heuristics by providing important solution bounds that can be found quickly \cite{SANTOS2019,EGEBLAD2009}.

% \begin{figure}[h]
%     \centering
%     \begin{subfigure}[b]{.45\linewidth}
%         \input{images/wb_front/layer39.tikz}
%         \caption{Frontal view}
%     \end{subfigure}
%     \begin{subfigure}[b]{.45\linewidth}
%         \input{images/wb_top/layer39.tikz}
%         \caption{Top view}
%     \end{subfigure}
%     \caption{Layer 39}
% \end{figure}
% \begin{figure}[h]
%     \centering
%     \begin{subfigure}[b]{.45\linewidth}
%         \input{images/wb_front/layer40.tikz}
%         \caption{Frontal view}
%     \end{subfigure}
%     \begin{subfigure}[b]{.45\linewidth}
%         \input{images/wb_top/layer40.tikz}
%         \caption{Top view}
%     \end{subfigure}
%     \caption{Layer 40}
% \end{figure}
% \begin{figure}[h]
%     \centering
%     \begin{subfigure}[b]{.45\linewidth}
%         \input{images/wb_front/layer41.tikz}
%         \caption{Frontal view}
%     \end{subfigure}
%     \begin{subfigure}[b]{.45\linewidth}
%         \input{images/wb_top/layer41.tikz}
%         \caption{Top view}
%     \end{subfigure}
%     \caption{Layer 41}
% \end{figure}
% \begin{figure}[h]
%     \centering
%     \begin{subfigure}[b]{.45\linewidth}
%         \input{images/wb_front/layer42.tikz}
%         \caption{Frontal view}
%     \end{subfigure}
%     \begin{subfigure}[b]{.45\linewidth}
%         \input{images/wb_top/layer42.tikz}
%         \caption{Top view}
%     \end{subfigure}
%     \caption{Layer 42}
% \end{figure}
% \begin{figure}[h]
%     \centering
%     \begin{subfigure}[b]{.45\linewidth}
%         \input{images/wb_front/layer43.tikz}
%         \caption{Frontal view}
%     \end{subfigure}
%     \begin{subfigure}[b]{.45\linewidth}
%         \input{images/wb_top/layer43.tikz}
%         \caption{Top view}
%     \end{subfigure}
%     \caption{Layer 43}
% \end{figure}
% \begin{figure}[h]
%     \centering
%     \begin{subfigure}[b]{.45\linewidth}
%         \input{images/wb_front/layer44.tikz}
%         \caption{Frontal view}
%     \end{subfigure}
%     \begin{subfigure}[b]{.45\linewidth}
%         \input{images/wb_top/layer44.tikz}
%         \caption{Top view}
%     \end{subfigure}
%     \caption{Layer 44}
% \end{figure}